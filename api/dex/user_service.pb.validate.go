// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: dex/user_service.proto

package dexpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ApproveWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveWithdrawalParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveWithdrawalParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveWithdrawalParamsMultiError, or nil if none found.
func (m *ApproveWithdrawalParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveWithdrawalParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Token

	// no validation rules for TxHash

	if len(errors) > 0 {
		return ApproveWithdrawalParamsMultiError(errors)
	}

	return nil
}

// ApproveWithdrawalParamsMultiError is an error wrapping multiple validation
// errors returned by ApproveWithdrawalParams.ValidateAll() if the designated
// constraints aren't met.
type ApproveWithdrawalParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveWithdrawalParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveWithdrawalParamsMultiError) AllErrors() []error { return m }

// ApproveWithdrawalParamsValidationError is the validation error returned by
// ApproveWithdrawalParams.Validate if the designated constraints aren't met.
type ApproveWithdrawalParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveWithdrawalParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveWithdrawalParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveWithdrawalParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveWithdrawalParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveWithdrawalParamsValidationError) ErrorName() string {
	return "ApproveWithdrawalParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveWithdrawalParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveWithdrawalParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveWithdrawalParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveWithdrawalParamsValidationError{}

// Validate checks the field values on ListUsersParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersParamsMultiError, or nil if none found.
func (m *ListUsersParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nickname

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListUsersParamsMultiError(errors)
	}

	return nil
}

// ListUsersParamsMultiError is an error wrapping multiple validation errors
// returned by ListUsersParams.ValidateAll() if the designated constraints
// aren't met.
type ListUsersParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersParamsMultiError) AllErrors() []error { return m }

// ListUsersParamsValidationError is the validation error returned by
// ListUsersParams.Validate if the designated constraints aren't met.
type ListUsersParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersParamsValidationError) ErrorName() string { return "ListUsersParamsValidationError" }

// Error satisfies the builtin error interface
func (e ListUsersParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersParamsValidationError{}

// Validate checks the field values on ResetUserWalletPasswordParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResetUserWalletPasswordParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetUserWalletPasswordParams with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ResetUserWalletPasswordParamsMultiError, or nil if none found.
func (m *ResetUserWalletPasswordParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetUserWalletPasswordParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OldPassword

	// no validation rules for NewPassword

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResetUserWalletPasswordParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResetUserWalletPasswordParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResetUserWalletPasswordParamsValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResetUserWalletPasswordParamsMultiError(errors)
	}

	return nil
}

// ResetUserWalletPasswordParamsMultiError is an error wrapping multiple
// validation errors returned by ResetUserWalletPasswordParams.ValidateAll()
// if the designated constraints aren't met.
type ResetUserWalletPasswordParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetUserWalletPasswordParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetUserWalletPasswordParamsMultiError) AllErrors() []error { return m }

// ResetUserWalletPasswordParamsValidationError is the validation error
// returned by ResetUserWalletPasswordParams.Validate if the designated
// constraints aren't met.
type ResetUserWalletPasswordParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetUserWalletPasswordParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetUserWalletPasswordParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetUserWalletPasswordParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetUserWalletPasswordParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetUserWalletPasswordParamsValidationError) ErrorName() string {
	return "ResetUserWalletPasswordParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ResetUserWalletPasswordParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetUserWalletPasswordParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetUserWalletPasswordParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetUserWalletPasswordParamsValidationError{}

// Validate checks the field values on ListUserWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserWithdrawalParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserWithdrawalParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserWithdrawalParamsMultiError, or nil if none found.
func (m *ListUserWithdrawalParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserWithdrawalParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserWithdrawalParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserWithdrawalParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserWithdrawalParamsValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListUserWithdrawalParamsMultiError(errors)
	}

	return nil
}

// ListUserWithdrawalParamsMultiError is an error wrapping multiple validation
// errors returned by ListUserWithdrawalParams.ValidateAll() if the designated
// constraints aren't met.
type ListUserWithdrawalParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserWithdrawalParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserWithdrawalParamsMultiError) AllErrors() []error { return m }

// ListUserWithdrawalParamsValidationError is the validation error returned by
// ListUserWithdrawalParams.Validate if the designated constraints aren't met.
type ListUserWithdrawalParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserWithdrawalParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserWithdrawalParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserWithdrawalParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserWithdrawalParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserWithdrawalParamsValidationError) ErrorName() string {
	return "ListUserWithdrawalParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserWithdrawalParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserWithdrawalParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserWithdrawalParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserWithdrawalParamsValidationError{}

// Validate checks the field values on ListWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWithdrawalParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWithdrawalParamsMultiError, or nil if none found.
func (m *ListWithdrawalParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWithdrawalParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListWithdrawalParamsMultiError(errors)
	}

	return nil
}

// ListWithdrawalParamsMultiError is an error wrapping multiple validation
// errors returned by ListWithdrawalParams.ValidateAll() if the designated
// constraints aren't met.
type ListWithdrawalParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWithdrawalParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWithdrawalParamsMultiError) AllErrors() []error { return m }

// ListWithdrawalParamsValidationError is the validation error returned by
// ListWithdrawalParams.Validate if the designated constraints aren't met.
type ListWithdrawalParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWithdrawalParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWithdrawalParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWithdrawalParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWithdrawalParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWithdrawalParamsValidationError) ErrorName() string {
	return "ListWithdrawalParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListWithdrawalParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWithdrawalParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWithdrawalParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWithdrawalParamsValidationError{}

// Validate checks the field values on CreateWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWithdrawalParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWithdrawalParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWithdrawalParamsMultiError, or nil if none found.
func (m *CreateWithdrawalParams) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWithdrawalParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateWithdrawalParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateWithdrawalParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateWithdrawalParamsValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateWithdrawalParamsMultiError(errors)
	}

	return nil
}

// CreateWithdrawalParamsMultiError is an error wrapping multiple validation
// errors returned by CreateWithdrawalParams.ValidateAll() if the designated
// constraints aren't met.
type CreateWithdrawalParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWithdrawalParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWithdrawalParamsMultiError) AllErrors() []error { return m }

// CreateWithdrawalParamsValidationError is the validation error returned by
// CreateWithdrawalParams.Validate if the designated constraints aren't met.
type CreateWithdrawalParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWithdrawalParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWithdrawalParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWithdrawalParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWithdrawalParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWithdrawalParamsValidationError) ErrorName() string {
	return "CreateWithdrawalParamsValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWithdrawalParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWithdrawalParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWithdrawalParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWithdrawalParamsValidationError{}

// Validate checks the field values on CreateWithdrawalResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWithdrawalResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWithdrawalResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWithdrawalResultMultiError, or nil if none found.
func (m *CreateWithdrawalResult) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWithdrawalResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateWithdrawalResultMultiError(errors)
	}

	return nil
}

// CreateWithdrawalResultMultiError is an error wrapping multiple validation
// errors returned by CreateWithdrawalResult.ValidateAll() if the designated
// constraints aren't met.
type CreateWithdrawalResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWithdrawalResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWithdrawalResultMultiError) AllErrors() []error { return m }

// CreateWithdrawalResultValidationError is the validation error returned by
// CreateWithdrawalResult.Validate if the designated constraints aren't met.
type CreateWithdrawalResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWithdrawalResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWithdrawalResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWithdrawalResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWithdrawalResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWithdrawalResultValidationError) ErrorName() string {
	return "CreateWithdrawalResultValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWithdrawalResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWithdrawalResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWithdrawalResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWithdrawalResultValidationError{}

// Validate checks the field values on SettleCommissionParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SettleCommissionParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleCommissionParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SettleCommissionParamsMultiError, or nil if none found.
func (m *SettleCommissionParams) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleCommissionParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimeStart() <= 0 {
		err := SettleCommissionParamsValidationError{
			field:  "TimeStart",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTimeEnd() <= 0 {
		err := SettleCommissionParamsValidationError{
			field:  "TimeEnd",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SettleCommissionParamsMultiError(errors)
	}

	return nil
}

// SettleCommissionParamsMultiError is an error wrapping multiple validation
// errors returned by SettleCommissionParams.ValidateAll() if the designated
// constraints aren't met.
type SettleCommissionParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleCommissionParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleCommissionParamsMultiError) AllErrors() []error { return m }

// SettleCommissionParamsValidationError is the validation error returned by
// SettleCommissionParams.Validate if the designated constraints aren't met.
type SettleCommissionParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleCommissionParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleCommissionParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleCommissionParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleCommissionParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleCommissionParamsValidationError) ErrorName() string {
	return "SettleCommissionParamsValidationError"
}

// Error satisfies the builtin error interface
func (e SettleCommissionParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleCommissionParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleCommissionParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleCommissionParamsValidationError{}

// Validate checks the field values on ListInviteUsersParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInviteUsersParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInviteUsersParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInviteUsersParamsMultiError, or nil if none found.
func (m *ListInviteUsersParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInviteUsersParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListInviteUsersParamsMultiError(errors)
	}

	return nil
}

// ListInviteUsersParamsMultiError is an error wrapping multiple validation
// errors returned by ListInviteUsersParams.ValidateAll() if the designated
// constraints aren't met.
type ListInviteUsersParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInviteUsersParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInviteUsersParamsMultiError) AllErrors() []error { return m }

// ListInviteUsersParamsValidationError is the validation error returned by
// ListInviteUsersParams.Validate if the designated constraints aren't met.
type ListInviteUsersParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInviteUsersParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInviteUsersParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInviteUsersParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInviteUsersParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInviteUsersParamsValidationError) ErrorName() string {
	return "ListInviteUsersParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListInviteUsersParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInviteUsersParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInviteUsersParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInviteUsersParamsValidationError{}

// Validate checks the field values on UserList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserListMultiError, or nil
// if none found.
func (m *UserList) ValidateAll() error {
	return m.validate(true)
}

func (m *UserList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserListValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return UserListMultiError(errors)
	}

	return nil
}

// UserListMultiError is an error wrapping multiple validation errors returned
// by UserList.ValidateAll() if the designated constraints aren't met.
type UserListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListMultiError) AllErrors() []error { return m }

// UserListValidationError is the validation error returned by
// UserList.Validate if the designated constraints aren't met.
type UserListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListValidationError) ErrorName() string { return "UserListValidationError" }

// Error satisfies the builtin error interface
func (e UserListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListValidationError{}

// Validate checks the field values on GetCommissionSummaryParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCommissionSummaryParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommissionSummaryParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCommissionSummaryParamsMultiError, or nil if none found.
func (m *GetCommissionSummaryParams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommissionSummaryParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCommissionSummaryParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCommissionSummaryParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCommissionSummaryParamsValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCommissionSummaryParamsMultiError(errors)
	}

	return nil
}

// GetCommissionSummaryParamsMultiError is an error wrapping multiple
// validation errors returned by GetCommissionSummaryParams.ValidateAll() if
// the designated constraints aren't met.
type GetCommissionSummaryParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommissionSummaryParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommissionSummaryParamsMultiError) AllErrors() []error { return m }

// GetCommissionSummaryParamsValidationError is the validation error returned
// by GetCommissionSummaryParams.Validate if the designated constraints aren't met.
type GetCommissionSummaryParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommissionSummaryParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommissionSummaryParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommissionSummaryParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommissionSummaryParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommissionSummaryParamsValidationError) ErrorName() string {
	return "GetCommissionSummaryParamsValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommissionSummaryParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommissionSummaryParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommissionSummaryParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommissionSummaryParamsValidationError{}

// Validate checks the field values on CommissionSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CommissionSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommissionSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommissionSummaryMultiError, or nil if none found.
func (m *CommissionSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *CommissionSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalCommissionAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSummaryValidationError{
					field:  "TotalCommissionAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSummaryValidationError{
					field:  "TotalCommissionAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalCommissionAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSummaryValidationError{
				field:  "TotalCommissionAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalTransactionAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSummaryValidationError{
					field:  "TotalTransactionAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSummaryValidationError{
					field:  "TotalTransactionAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalTransactionAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSummaryValidationError{
				field:  "TotalTransactionAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InviteUserCount

	// no validation rules for ValidInviteUserCount

	// no validation rules for CommissionRate

	if len(errors) > 0 {
		return CommissionSummaryMultiError(errors)
	}

	return nil
}

// CommissionSummaryMultiError is an error wrapping multiple validation errors
// returned by CommissionSummary.ValidateAll() if the designated constraints
// aren't met.
type CommissionSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommissionSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommissionSummaryMultiError) AllErrors() []error { return m }

// CommissionSummaryValidationError is the validation error returned by
// CommissionSummary.Validate if the designated constraints aren't met.
type CommissionSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommissionSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommissionSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommissionSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommissionSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommissionSummaryValidationError) ErrorName() string {
	return "CommissionSummaryValidationError"
}

// Error satisfies the builtin error interface
func (e CommissionSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommissionSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommissionSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommissionSummaryValidationError{}

// Validate checks the field values on GetCommissionSettlementSummaryParams
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetCommissionSettlementSummaryParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommissionSettlementSummaryParams
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetCommissionSettlementSummaryParamsMultiError, or nil if none found.
func (m *GetCommissionSettlementSummaryParams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommissionSettlementSummaryParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCommissionSettlementSummaryParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCommissionSettlementSummaryParamsValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCommissionSettlementSummaryParamsValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCommissionSettlementSummaryParamsMultiError(errors)
	}

	return nil
}

// GetCommissionSettlementSummaryParamsMultiError is an error wrapping multiple
// validation errors returned by
// GetCommissionSettlementSummaryParams.ValidateAll() if the designated
// constraints aren't met.
type GetCommissionSettlementSummaryParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommissionSettlementSummaryParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommissionSettlementSummaryParamsMultiError) AllErrors() []error { return m }

// GetCommissionSettlementSummaryParamsValidationError is the validation error
// returned by GetCommissionSettlementSummaryParams.Validate if the designated
// constraints aren't met.
type GetCommissionSettlementSummaryParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommissionSettlementSummaryParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommissionSettlementSummaryParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommissionSettlementSummaryParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommissionSettlementSummaryParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommissionSettlementSummaryParamsValidationError) ErrorName() string {
	return "GetCommissionSettlementSummaryParamsValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommissionSettlementSummaryParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommissionSettlementSummaryParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommissionSettlementSummaryParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommissionSettlementSummaryParamsValidationError{}

// Validate checks the field values on CommissionSettlementStats_ByStatus with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CommissionSettlementStats_ByStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommissionSettlementStats_ByStatus
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CommissionSettlementStats_ByStatusMultiError, or nil if none found.
func (m *CommissionSettlementStats_ByStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *CommissionSettlementStats_ByStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByStatusValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByStatusValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementStats_ByStatusValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByStatusValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByStatusValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementStats_ByStatusValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommissionSettlementStats_ByStatusMultiError(errors)
	}

	return nil
}

// CommissionSettlementStats_ByStatusMultiError is an error wrapping multiple
// validation errors returned by
// CommissionSettlementStats_ByStatus.ValidateAll() if the designated
// constraints aren't met.
type CommissionSettlementStats_ByStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommissionSettlementStats_ByStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommissionSettlementStats_ByStatusMultiError) AllErrors() []error { return m }

// CommissionSettlementStats_ByStatusValidationError is the validation error
// returned by CommissionSettlementStats_ByStatus.Validate if the designated
// constraints aren't met.
type CommissionSettlementStats_ByStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommissionSettlementStats_ByStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommissionSettlementStats_ByStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommissionSettlementStats_ByStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommissionSettlementStats_ByStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommissionSettlementStats_ByStatusValidationError) ErrorName() string {
	return "CommissionSettlementStats_ByStatusValidationError"
}

// Error satisfies the builtin error interface
func (e CommissionSettlementStats_ByStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommissionSettlementStats_ByStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommissionSettlementStats_ByStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommissionSettlementStats_ByStatusValidationError{}

// Validate checks the field values on CommissionSettlementStats_ByToken with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CommissionSettlementStats_ByToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommissionSettlementStats_ByToken
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CommissionSettlementStats_ByTokenMultiError, or nil if none found.
func (m *CommissionSettlementStats_ByToken) ValidateAll() error {
	return m.validate(true)
}

func (m *CommissionSettlementStats_ByToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementStats_ByTokenValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementStats_ByTokenValidationError{
				field:  "Total",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStats() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
						field:  fmt.Sprintf("Stats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommissionSettlementStats_ByTokenValidationError{
						field:  fmt.Sprintf("Stats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommissionSettlementStats_ByTokenValidationError{
					field:  fmt.Sprintf("Stats[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CommissionSettlementStats_ByTokenMultiError(errors)
	}

	return nil
}

// CommissionSettlementStats_ByTokenMultiError is an error wrapping multiple
// validation errors returned by
// CommissionSettlementStats_ByToken.ValidateAll() if the designated
// constraints aren't met.
type CommissionSettlementStats_ByTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommissionSettlementStats_ByTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommissionSettlementStats_ByTokenMultiError) AllErrors() []error { return m }

// CommissionSettlementStats_ByTokenValidationError is the validation error
// returned by CommissionSettlementStats_ByToken.Validate if the designated
// constraints aren't met.
type CommissionSettlementStats_ByTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommissionSettlementStats_ByTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommissionSettlementStats_ByTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommissionSettlementStats_ByTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommissionSettlementStats_ByTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommissionSettlementStats_ByTokenValidationError) ErrorName() string {
	return "CommissionSettlementStats_ByTokenValidationError"
}

// Error satisfies the builtin error interface
func (e CommissionSettlementStats_ByTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommissionSettlementStats_ByToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommissionSettlementStats_ByTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommissionSettlementStats_ByTokenValidationError{}

// Validate checks the field values on CommissionSettlementSummary with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommissionSettlementSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommissionSettlementSummary with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommissionSettlementSummaryMultiError, or nil if none found.
func (m *CommissionSettlementSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *CommissionSettlementSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementSummaryValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementSummaryValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementSummaryValidationError{
				field:  "Total",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTokenStats() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommissionSettlementSummaryValidationError{
						field:  fmt.Sprintf("TokenStats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommissionSettlementSummaryValidationError{
						field:  fmt.Sprintf("TokenStats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommissionSettlementSummaryValidationError{
					field:  fmt.Sprintf("TokenStats[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommissionSettlementSummaryValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommissionSettlementSummaryValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommissionSettlementSummaryValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommissionSettlementSummaryMultiError(errors)
	}

	return nil
}

// CommissionSettlementSummaryMultiError is an error wrapping multiple
// validation errors returned by CommissionSettlementSummary.ValidateAll() if
// the designated constraints aren't met.
type CommissionSettlementSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommissionSettlementSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommissionSettlementSummaryMultiError) AllErrors() []error { return m }

// CommissionSettlementSummaryValidationError is the validation error returned
// by CommissionSettlementSummary.Validate if the designated constraints
// aren't met.
type CommissionSettlementSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommissionSettlementSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommissionSettlementSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommissionSettlementSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommissionSettlementSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommissionSettlementSummaryValidationError) ErrorName() string {
	return "CommissionSettlementSummaryValidationError"
}

// Error satisfies the builtin error interface
func (e CommissionSettlementSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommissionSettlementSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommissionSettlementSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommissionSettlementSummaryValidationError{}

// Validate checks the field values on WithdrawSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WithdrawSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawSettingsMultiError, or nil if none found.
func (m *WithdrawSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WithdrawSettingsValidationError{
					field:  "Threshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WithdrawSettingsValidationError{
					field:  "Threshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WithdrawSettingsValidationError{
				field:  "Threshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWallet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WithdrawSettingsValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WithdrawSettingsValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWallet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WithdrawSettingsValidationError{
				field:  "Wallet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WithdrawSettingsMultiError(errors)
	}

	return nil
}

// WithdrawSettingsMultiError is an error wrapping multiple validation errors
// returned by WithdrawSettings.ValidateAll() if the designated constraints
// aren't met.
type WithdrawSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawSettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawSettingsMultiError) AllErrors() []error { return m }

// WithdrawSettingsValidationError is the validation error returned by
// WithdrawSettings.Validate if the designated constraints aren't met.
type WithdrawSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawSettingsValidationError) ErrorName() string { return "WithdrawSettingsValidationError" }

// Error satisfies the builtin error interface
func (e WithdrawSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawSettingsValidationError{}
