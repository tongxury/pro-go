// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v5.29.3
// source: dex/market_service.proto

package dexpb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationMarketServiceGetToken = "/api.dex.MarketService/GetToken"
const OperationMarketServiceListFollowingTrades = "/api.dex.MarketService/ListFollowingTrades"
const OperationMarketServiceListTokenTrades = "/api.dex.MarketService/ListTokenTrades"
const OperationMarketServiceListTokens = "/api.dex.MarketService/ListTokens"

type MarketServiceHTTPServer interface {
	GetToken(context.Context, *GetTokenParams) (*Token, error)
	// ListFollowingTrades activities
	ListFollowingTrades(context.Context, *ListFollowingTradesParams) (*TradeList, error)
	ListTokenTrades(context.Context, *ListTokenTradesParams) (*TradeList, error)
	ListTokens(context.Context, *ListTokensParams) (*TokenList, error)
}

func RegisterMarketServiceHTTPServer(s *http.Server, srv MarketServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/api/tgbot/tokens", _MarketService_ListTokens0_HTTP_Handler(srv))
	r.GET("/api/tgbot/tokens/{id}", _MarketService_GetToken1_HTTP_Handler(srv))
	r.GET("/api/tgbot/tokens/{token}/trades", _MarketService_ListTokenTrades0_HTTP_Handler(srv))
	r.GET("/api/tgbot/following-trades", _MarketService_ListFollowingTrades0_HTTP_Handler(srv))
}

func _MarketService_ListTokens0_HTTP_Handler(srv MarketServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTokensParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMarketServiceListTokens)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTokens(ctx, req.(*ListTokensParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TokenList)
		return ctx.Result(200, reply)
	}
}

func _MarketService_GetToken1_HTTP_Handler(srv MarketServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTokenParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMarketServiceGetToken)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetToken(ctx, req.(*GetTokenParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Token)
		return ctx.Result(200, reply)
	}
}

func _MarketService_ListTokenTrades0_HTTP_Handler(srv MarketServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTokenTradesParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMarketServiceListTokenTrades)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTokenTrades(ctx, req.(*ListTokenTradesParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TradeList)
		return ctx.Result(200, reply)
	}
}

func _MarketService_ListFollowingTrades0_HTTP_Handler(srv MarketServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListFollowingTradesParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMarketServiceListFollowingTrades)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListFollowingTrades(ctx, req.(*ListFollowingTradesParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TradeList)
		return ctx.Result(200, reply)
	}
}

type MarketServiceHTTPClient interface {
	GetToken(ctx context.Context, req *GetTokenParams, opts ...http.CallOption) (rsp *Token, err error)
	// ListFollowingTrades activities
	ListFollowingTrades(ctx context.Context, req *ListFollowingTradesParams, opts ...http.CallOption) (rsp *TradeList, err error)
	ListTokenTrades(ctx context.Context, req *ListTokenTradesParams, opts ...http.CallOption) (rsp *TradeList, err error)
	ListTokens(ctx context.Context, req *ListTokensParams, opts ...http.CallOption) (rsp *TokenList, err error)
}

type MarketServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewMarketServiceHTTPClient(client *http.Client) MarketServiceHTTPClient {
	return &MarketServiceHTTPClientImpl{client}
}

func (c *MarketServiceHTTPClientImpl) GetToken(ctx context.Context, in *GetTokenParams, opts ...http.CallOption) (*Token, error) {
	var out Token
	pattern := "/api/tgbot/tokens/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMarketServiceGetToken))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListFollowingTrades activities
func (c *MarketServiceHTTPClientImpl) ListFollowingTrades(ctx context.Context, in *ListFollowingTradesParams, opts ...http.CallOption) (*TradeList, error) {
	var out TradeList
	pattern := "/api/tgbot/following-trades"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMarketServiceListFollowingTrades))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MarketServiceHTTPClientImpl) ListTokenTrades(ctx context.Context, in *ListTokenTradesParams, opts ...http.CallOption) (*TradeList, error) {
	var out TradeList
	pattern := "/api/tgbot/tokens/{token}/trades"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMarketServiceListTokenTrades))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MarketServiceHTTPClientImpl) ListTokens(ctx context.Context, in *ListTokensParams, opts ...http.CallOption) (*TokenList, error) {
	var out TokenList
	pattern := "/api/tgbot/tokens"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMarketServiceListTokens))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
