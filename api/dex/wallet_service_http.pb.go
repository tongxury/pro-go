// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v5.29.3
// source: dex/wallet_service.proto

package dexpb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationWalletServiceAddFollowingWallet = "/api.dex.WalletService/AddFollowingWallet"
const OperationWalletServiceDeleteFollowingWallet = "/api.dex.WalletService/DeleteFollowingWallet"
const OperationWalletServiceExportUserWalletPrivateKey = "/api.dex.WalletService/ExportUserWalletPrivateKey"
const OperationWalletServiceGetUserWallet = "/api.dex.WalletService/GetUserWallet"
const OperationWalletServiceGetWalletPosition = "/api.dex.WalletService/GetWalletPosition"
const OperationWalletServiceListUserFollowingWallets = "/api.dex.WalletService/ListUserFollowingWallets"
const OperationWalletServiceListUserWallets = "/api.dex.WalletService/ListUserWallets"
const OperationWalletServiceListWalletPositions = "/api.dex.WalletService/ListWalletPositions"
const OperationWalletServiceReplaceFollowingWallet = "/api.dex.WalletService/ReplaceFollowingWallet"
const OperationWalletServiceTransferOut = "/api.dex.WalletService/TransferOut"
const OperationWalletServiceUpdateFollowingWallet = "/api.dex.WalletService/UpdateFollowingWallet"
const OperationWalletServiceUpdateUserTokenRelation = "/api.dex.WalletService/UpdateUserTokenRelation"

type WalletServiceHTTPServer interface {
	AddFollowingWallet(context.Context, *AddFollowingWalletParams) (*emptypb.Empty, error)
	DeleteFollowingWallet(context.Context, *DeleteFollowingWalletParams) (*emptypb.Empty, error)
	ExportUserWalletPrivateKey(context.Context, *ExportUserWalletPrivateKeyParams) (*emptypb.Empty, error)
	GetUserWallet(context.Context, *GetUserWalletParams) (*Wallet, error)
	GetWalletPosition(context.Context, *GetWalletPositionParams) (*WalletPosition, error)
	ListUserFollowingWallets(context.Context, *ListUserFollowingWalletsParams) (*UserWalletRelationList, error)
	// ListUserWallets wallets
	ListUserWallets(context.Context, *ListUserWalletsParams) (*WalletList, error)
	ListWalletPositions(context.Context, *ListWalletPositionsParams) (*WalletPositionList, error)
	ReplaceFollowingWallet(context.Context, *ReplaceFollowingWalletParams) (*UserWalletRelation, error)
	TransferOut(context.Context, *TransferOutParams) (*TransferOutResult, error)
	UpdateFollowingWallet(context.Context, *UpdateFollowingWalletParams) (*UserWalletRelation, error)
	UpdateUserTokenRelation(context.Context, *UpdateUserTokenRelationParams) (*Token, error)
}

func RegisterWalletServiceHTTPServer(s *http.Server, srv WalletServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/api/tgbot/users/me/following-wallets", _WalletService_ListUserFollowingWallets0_HTTP_Handler(srv))
	r.POST("/api/tgbot/users/me/following-wallets", _WalletService_AddFollowingWallet0_HTTP_Handler(srv))
	r.PUT("/api/tgbot/users/me/following-wallets", _WalletService_ReplaceFollowingWallet0_HTTP_Handler(srv))
	r.PATCH("/api/tgbot/users/me/following-wallets/{id}", _WalletService_UpdateFollowingWallet0_HTTP_Handler(srv))
	r.DELETE("/api/tgbot/users/me/following-wallets/{id}", _WalletService_DeleteFollowingWallet0_HTTP_Handler(srv))
	r.GET("/api/tgbot/users/me/wallets", _WalletService_ListUserWallets0_HTTP_Handler(srv))
	r.PATCH("/api/tgbot/users/me/wallets/{id}/transferOut", _WalletService_TransferOut0_HTTP_Handler(srv))
	r.GET("/api/tgbot/wallets/{id}/positions", _WalletService_ListWalletPositions0_HTTP_Handler(srv))
	r.GET("/api/tgbot/wallets/{wallet}/positions/{token}", _WalletService_GetWalletPosition0_HTTP_Handler(srv))
	r.GET("/api/tgbot/users/me/wallets/{id}", _WalletService_GetUserWallet0_HTTP_Handler(srv))
	r.GET("/api/tgbot/users/me/wallets/{id}/pk", _WalletService_ExportUserWalletPrivateKey0_HTTP_Handler(srv))
	r.PATCH("/api/tgbot/users/me/tokens/{id}", _WalletService_UpdateUserTokenRelation0_HTTP_Handler(srv))
}

func _WalletService_ListUserFollowingWallets0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListUserFollowingWalletsParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceListUserFollowingWallets)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListUserFollowingWallets(ctx, req.(*ListUserFollowingWalletsParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserWalletRelationList)
		return ctx.Result(200, reply)
	}
}

func _WalletService_AddFollowingWallet0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddFollowingWalletParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceAddFollowingWallet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddFollowingWallet(ctx, req.(*AddFollowingWalletParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _WalletService_ReplaceFollowingWallet0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReplaceFollowingWalletParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceReplaceFollowingWallet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReplaceFollowingWallet(ctx, req.(*ReplaceFollowingWalletParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserWalletRelation)
		return ctx.Result(200, reply)
	}
}

func _WalletService_UpdateFollowingWallet0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateFollowingWalletParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceUpdateFollowingWallet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateFollowingWallet(ctx, req.(*UpdateFollowingWalletParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserWalletRelation)
		return ctx.Result(200, reply)
	}
}

func _WalletService_DeleteFollowingWallet0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteFollowingWalletParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceDeleteFollowingWallet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteFollowingWallet(ctx, req.(*DeleteFollowingWalletParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _WalletService_ListUserWallets0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListUserWalletsParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceListUserWallets)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListUserWallets(ctx, req.(*ListUserWalletsParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WalletList)
		return ctx.Result(200, reply)
	}
}

func _WalletService_TransferOut0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TransferOutParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceTransferOut)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TransferOut(ctx, req.(*TransferOutParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TransferOutResult)
		return ctx.Result(200, reply)
	}
}

func _WalletService_ListWalletPositions0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListWalletPositionsParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceListWalletPositions)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListWalletPositions(ctx, req.(*ListWalletPositionsParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WalletPositionList)
		return ctx.Result(200, reply)
	}
}

func _WalletService_GetWalletPosition0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetWalletPositionParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceGetWalletPosition)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetWalletPosition(ctx, req.(*GetWalletPositionParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WalletPosition)
		return ctx.Result(200, reply)
	}
}

func _WalletService_GetUserWallet0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetUserWalletParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceGetUserWallet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUserWallet(ctx, req.(*GetUserWalletParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Wallet)
		return ctx.Result(200, reply)
	}
}

func _WalletService_ExportUserWalletPrivateKey0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ExportUserWalletPrivateKeyParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceExportUserWalletPrivateKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ExportUserWalletPrivateKey(ctx, req.(*ExportUserWalletPrivateKeyParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _WalletService_UpdateUserTokenRelation0_HTTP_Handler(srv WalletServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateUserTokenRelationParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWalletServiceUpdateUserTokenRelation)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateUserTokenRelation(ctx, req.(*UpdateUserTokenRelationParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Token)
		return ctx.Result(200, reply)
	}
}

type WalletServiceHTTPClient interface {
	AddFollowingWallet(ctx context.Context, req *AddFollowingWalletParams, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	DeleteFollowingWallet(ctx context.Context, req *DeleteFollowingWalletParams, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	ExportUserWalletPrivateKey(ctx context.Context, req *ExportUserWalletPrivateKeyParams, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	GetUserWallet(ctx context.Context, req *GetUserWalletParams, opts ...http.CallOption) (rsp *Wallet, err error)
	GetWalletPosition(ctx context.Context, req *GetWalletPositionParams, opts ...http.CallOption) (rsp *WalletPosition, err error)
	ListUserFollowingWallets(ctx context.Context, req *ListUserFollowingWalletsParams, opts ...http.CallOption) (rsp *UserWalletRelationList, err error)
	// ListUserWallets wallets
	ListUserWallets(ctx context.Context, req *ListUserWalletsParams, opts ...http.CallOption) (rsp *WalletList, err error)
	ListWalletPositions(ctx context.Context, req *ListWalletPositionsParams, opts ...http.CallOption) (rsp *WalletPositionList, err error)
	ReplaceFollowingWallet(ctx context.Context, req *ReplaceFollowingWalletParams, opts ...http.CallOption) (rsp *UserWalletRelation, err error)
	TransferOut(ctx context.Context, req *TransferOutParams, opts ...http.CallOption) (rsp *TransferOutResult, err error)
	UpdateFollowingWallet(ctx context.Context, req *UpdateFollowingWalletParams, opts ...http.CallOption) (rsp *UserWalletRelation, err error)
	UpdateUserTokenRelation(ctx context.Context, req *UpdateUserTokenRelationParams, opts ...http.CallOption) (rsp *Token, err error)
}

type WalletServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewWalletServiceHTTPClient(client *http.Client) WalletServiceHTTPClient {
	return &WalletServiceHTTPClientImpl{client}
}

func (c *WalletServiceHTTPClientImpl) AddFollowingWallet(ctx context.Context, in *AddFollowingWalletParams, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/tgbot/users/me/following-wallets"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWalletServiceAddFollowingWallet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) DeleteFollowingWallet(ctx context.Context, in *DeleteFollowingWalletParams, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/tgbot/users/me/following-wallets/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceDeleteFollowingWallet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) ExportUserWalletPrivateKey(ctx context.Context, in *ExportUserWalletPrivateKeyParams, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/tgbot/users/me/wallets/{id}/pk"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceExportUserWalletPrivateKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) GetUserWallet(ctx context.Context, in *GetUserWalletParams, opts ...http.CallOption) (*Wallet, error) {
	var out Wallet
	pattern := "/api/tgbot/users/me/wallets/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceGetUserWallet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) GetWalletPosition(ctx context.Context, in *GetWalletPositionParams, opts ...http.CallOption) (*WalletPosition, error) {
	var out WalletPosition
	pattern := "/api/tgbot/wallets/{wallet}/positions/{token}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceGetWalletPosition))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) ListUserFollowingWallets(ctx context.Context, in *ListUserFollowingWalletsParams, opts ...http.CallOption) (*UserWalletRelationList, error) {
	var out UserWalletRelationList
	pattern := "/api/tgbot/users/me/following-wallets"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceListUserFollowingWallets))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListUserWallets wallets
func (c *WalletServiceHTTPClientImpl) ListUserWallets(ctx context.Context, in *ListUserWalletsParams, opts ...http.CallOption) (*WalletList, error) {
	var out WalletList
	pattern := "/api/tgbot/users/me/wallets"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceListUserWallets))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) ListWalletPositions(ctx context.Context, in *ListWalletPositionsParams, opts ...http.CallOption) (*WalletPositionList, error) {
	var out WalletPositionList
	pattern := "/api/tgbot/wallets/{id}/positions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWalletServiceListWalletPositions))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) ReplaceFollowingWallet(ctx context.Context, in *ReplaceFollowingWalletParams, opts ...http.CallOption) (*UserWalletRelation, error) {
	var out UserWalletRelation
	pattern := "/api/tgbot/users/me/following-wallets"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWalletServiceReplaceFollowingWallet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) TransferOut(ctx context.Context, in *TransferOutParams, opts ...http.CallOption) (*TransferOutResult, error) {
	var out TransferOutResult
	pattern := "/api/tgbot/users/me/wallets/{id}/transferOut"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWalletServiceTransferOut))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) UpdateFollowingWallet(ctx context.Context, in *UpdateFollowingWalletParams, opts ...http.CallOption) (*UserWalletRelation, error) {
	var out UserWalletRelation
	pattern := "/api/tgbot/users/me/following-wallets/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWalletServiceUpdateFollowingWallet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WalletServiceHTTPClientImpl) UpdateUserTokenRelation(ctx context.Context, in *UpdateUserTokenRelationParams, opts ...http.CallOption) (*Token, error) {
	var out Token
	pattern := "/api/tgbot/users/me/tokens/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWalletServiceUpdateUserTokenRelation))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
