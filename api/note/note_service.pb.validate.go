// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: note/note_service.proto

package notepb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetMeetingParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetMeetingParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMeetingParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMeetingParamsMultiError, or nil if none found.
func (m *GetMeetingParams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMeetingParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetMeetingParamsMultiError(errors)
	}

	return nil
}

// GetMeetingParamsMultiError is an error wrapping multiple validation errors
// returned by GetMeetingParams.ValidateAll() if the designated constraints
// aren't met.
type GetMeetingParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMeetingParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMeetingParamsMultiError) AllErrors() []error { return m }

// GetMeetingParamsValidationError is the validation error returned by
// GetMeetingParams.Validate if the designated constraints aren't met.
type GetMeetingParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMeetingParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMeetingParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMeetingParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMeetingParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMeetingParamsValidationError) ErrorName() string { return "GetMeetingParamsValidationError" }

// Error satisfies the builtin error interface
func (e GetMeetingParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMeetingParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMeetingParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMeetingParamsValidationError{}

// Validate checks the field values on UpdateMeetingQuestionParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMeetingQuestionParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMeetingQuestionParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMeetingQuestionParamsMultiError, or nil if none found.
func (m *UpdateMeetingQuestionParams) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMeetingQuestionParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Question

	if len(errors) > 0 {
		return UpdateMeetingQuestionParamsMultiError(errors)
	}

	return nil
}

// UpdateMeetingQuestionParamsMultiError is an error wrapping multiple
// validation errors returned by UpdateMeetingQuestionParams.ValidateAll() if
// the designated constraints aren't met.
type UpdateMeetingQuestionParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMeetingQuestionParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMeetingQuestionParamsMultiError) AllErrors() []error { return m }

// UpdateMeetingQuestionParamsValidationError is the validation error returned
// by UpdateMeetingQuestionParams.Validate if the designated constraints
// aren't met.
type UpdateMeetingQuestionParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMeetingQuestionParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMeetingQuestionParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMeetingQuestionParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMeetingQuestionParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMeetingQuestionParamsValidationError) ErrorName() string {
	return "UpdateMeetingQuestionParamsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMeetingQuestionParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMeetingQuestionParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMeetingQuestionParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMeetingQuestionParamsValidationError{}

// Validate checks the field values on AddMeetingParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddMeetingParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddMeetingParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddMeetingParamsMultiError, or nil if none found.
func (m *AddMeetingParams) ValidateAll() error {
	return m.validate(true)
}

func (m *AddMeetingParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExpertId

	// no validation rules for Topic

	// no validation rules for By

	if len(errors) > 0 {
		return AddMeetingParamsMultiError(errors)
	}

	return nil
}

// AddMeetingParamsMultiError is an error wrapping multiple validation errors
// returned by AddMeetingParams.ValidateAll() if the designated constraints
// aren't met.
type AddMeetingParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddMeetingParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddMeetingParamsMultiError) AllErrors() []error { return m }

// AddMeetingParamsValidationError is the validation error returned by
// AddMeetingParams.Validate if the designated constraints aren't met.
type AddMeetingParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddMeetingParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddMeetingParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddMeetingParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddMeetingParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddMeetingParamsValidationError) ErrorName() string { return "AddMeetingParamsValidationError" }

// Error satisfies the builtin error interface
func (e AddMeetingParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddMeetingParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddMeetingParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddMeetingParamsValidationError{}

// Validate checks the field values on Meeting with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Meeting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Meeting with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MeetingMultiError, or nil if none found.
func (m *Meeting) ValidateAll() error {
	return m.validate(true)
}

func (m *Meeting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XId

	if all {
		switch v := interface{}(m.GetExpert()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeetingValidationError{
					field:  "Expert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeetingValidationError{
					field:  "Expert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpert()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeetingValidationError{
				field:  "Expert",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTopic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeetingValidationError{
					field:  "Topic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeetingValidationError{
					field:  "Topic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTopic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeetingValidationError{
				field:  "Topic",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for By

	// no validation rules for Question

	// no validation rules for Status

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return MeetingMultiError(errors)
	}

	return nil
}

// MeetingMultiError is an error wrapping multiple validation errors returned
// by Meeting.ValidateAll() if the designated constraints aren't met.
type MeetingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeetingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeetingMultiError) AllErrors() []error { return m }

// MeetingValidationError is the validation error returned by Meeting.Validate
// if the designated constraints aren't met.
type MeetingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeetingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeetingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeetingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeetingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeetingValidationError) ErrorName() string { return "MeetingValidationError" }

// Error satisfies the builtin error interface
func (e MeetingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeeting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeetingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeetingValidationError{}

// Validate checks the field values on AddCommentParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddCommentParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCommentParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCommentParamsMultiError, or nil if none found.
func (m *AddCommentParams) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCommentParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MeetingId

	// no validation rules for Content

	// no validation rules for ExpertId

	if len(errors) > 0 {
		return AddCommentParamsMultiError(errors)
	}

	return nil
}

// AddCommentParamsMultiError is an error wrapping multiple validation errors
// returned by AddCommentParams.ValidateAll() if the designated constraints
// aren't met.
type AddCommentParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCommentParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCommentParamsMultiError) AllErrors() []error { return m }

// AddCommentParamsValidationError is the validation error returned by
// AddCommentParams.Validate if the designated constraints aren't met.
type AddCommentParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCommentParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCommentParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCommentParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCommentParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCommentParamsValidationError) ErrorName() string { return "AddCommentParamsValidationError" }

// Error satisfies the builtin error interface
func (e AddCommentParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCommentParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCommentParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCommentParamsValidationError{}

// Validate checks the field values on ListCommentsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommentsParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommentsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommentsParamsMultiError, or nil if none found.
func (m *ListCommentsParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommentsParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Category

	// no validation rules for ExpertId

	if len(errors) > 0 {
		return ListCommentsParamsMultiError(errors)
	}

	return nil
}

// ListCommentsParamsMultiError is an error wrapping multiple validation errors
// returned by ListCommentsParams.ValidateAll() if the designated constraints
// aren't met.
type ListCommentsParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommentsParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommentsParamsMultiError) AllErrors() []error { return m }

// ListCommentsParamsValidationError is the validation error returned by
// ListCommentsParams.Validate if the designated constraints aren't met.
type ListCommentsParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommentsParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommentsParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommentsParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommentsParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommentsParamsValidationError) ErrorName() string {
	return "ListCommentsParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommentsParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommentsParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommentsParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommentsParamsValidationError{}

// Validate checks the field values on Comment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Comment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Comment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CommentMultiError, or nil if none found.
func (m *Comment) ValidateAll() error {
	return m.validate(true)
}

func (m *Comment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XId

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Content

	// no validation rules for CreatedAt

	if all {
		switch v := interface{}(m.GetExpert()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "Expert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "Expert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpert()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentValidationError{
				field:  "Expert",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeeting()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "Meeting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentValidationError{
					field:  "Meeting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeeting()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentValidationError{
				field:  "Meeting",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommentMultiError(errors)
	}

	return nil
}

// CommentMultiError is an error wrapping multiple validation errors returned
// by Comment.ValidateAll() if the designated constraints aren't met.
type CommentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentMultiError) AllErrors() []error { return m }

// CommentValidationError is the validation error returned by Comment.Validate
// if the designated constraints aren't met.
type CommentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentValidationError) ErrorName() string { return "CommentValidationError" }

// Error satisfies the builtin error interface
func (e CommentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentValidationError{}

// Validate checks the field values on CommentList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommentList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommentListMultiError, or
// nil if none found.
func (m *CommentList) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommentListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommentListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommentListValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for HasMore

	// no validation rules for Page

	if len(errors) > 0 {
		return CommentListMultiError(errors)
	}

	return nil
}

// CommentListMultiError is an error wrapping multiple validation errors
// returned by CommentList.ValidateAll() if the designated constraints aren't met.
type CommentListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentListMultiError) AllErrors() []error { return m }

// CommentListValidationError is the validation error returned by
// CommentList.Validate if the designated constraints aren't met.
type CommentListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentListValidationError) ErrorName() string { return "CommentListValidationError" }

// Error satisfies the builtin error interface
func (e CommentListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentListValidationError{}

// Validate checks the field values on GetExpertParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExpertParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExpertParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExpertParamsMultiError, or nil if none found.
func (m *GetExpertParams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExpertParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetExpertParamsMultiError(errors)
	}

	return nil
}

// GetExpertParamsMultiError is an error wrapping multiple validation errors
// returned by GetExpertParams.ValidateAll() if the designated constraints
// aren't met.
type GetExpertParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExpertParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExpertParamsMultiError) AllErrors() []error { return m }

// GetExpertParamsValidationError is the validation error returned by
// GetExpertParams.Validate if the designated constraints aren't met.
type GetExpertParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExpertParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExpertParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExpertParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExpertParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExpertParamsValidationError) ErrorName() string { return "GetExpertParamsValidationError" }

// Error satisfies the builtin error interface
func (e GetExpertParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExpertParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExpertParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExpertParamsValidationError{}

// Validate checks the field values on ListExpertsParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListExpertsParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExpertsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExpertsParamsMultiError, or nil if none found.
func (m *ListExpertsParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExpertsParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	if len(errors) > 0 {
		return ListExpertsParamsMultiError(errors)
	}

	return nil
}

// ListExpertsParamsMultiError is an error wrapping multiple validation errors
// returned by ListExpertsParams.ValidateAll() if the designated constraints
// aren't met.
type ListExpertsParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExpertsParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExpertsParamsMultiError) AllErrors() []error { return m }

// ListExpertsParamsValidationError is the validation error returned by
// ListExpertsParams.Validate if the designated constraints aren't met.
type ListExpertsParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExpertsParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExpertsParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExpertsParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExpertsParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExpertsParamsValidationError) ErrorName() string {
	return "ListExpertsParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListExpertsParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExpertsParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExpertsParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExpertsParamsValidationError{}

// Validate checks the field values on ExpertList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpertList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpertList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpertListMultiError, or
// nil if none found.
func (m *ExpertList) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpertList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpertListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpertListValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpertListValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for HasMore

	// no validation rules for Page

	if len(errors) > 0 {
		return ExpertListMultiError(errors)
	}

	return nil
}

// ExpertListMultiError is an error wrapping multiple validation errors
// returned by ExpertList.ValidateAll() if the designated constraints aren't met.
type ExpertListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpertListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpertListMultiError) AllErrors() []error { return m }

// ExpertListValidationError is the validation error returned by
// ExpertList.Validate if the designated constraints aren't met.
type ExpertListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpertListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpertListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpertListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpertListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpertListValidationError) ErrorName() string { return "ExpertListValidationError" }

// Error satisfies the builtin error interface
func (e ExpertListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpertList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpertListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpertListValidationError{}

// Validate checks the field values on Expert with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expert) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expert with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpertMultiError, or nil if none found.
func (m *Expert) ValidateAll() error {
	return m.validate(true)
}

func (m *Expert) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XId

	// no validation rules for Name

	// no validation rules for Cover

	for idx, item := range m.GetTopics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpertValidationError{
						field:  fmt.Sprintf("Topics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpertValidationError{
						field:  fmt.Sprintf("Topics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpertValidationError{
					field:  fmt.Sprintf("Topics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpertValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpertValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpertValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MeetingCount

	// no validation rules for Price

	// no validation rules for Rating

	// no validation rules for Avatar

	// no validation rules for Desc

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return ExpertMultiError(errors)
	}

	return nil
}

// ExpertMultiError is an error wrapping multiple validation errors returned by
// Expert.ValidateAll() if the designated constraints aren't met.
type ExpertMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpertMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpertMultiError) AllErrors() []error { return m }

// ExpertValidationError is the validation error returned by Expert.Validate if
// the designated constraints aren't met.
type ExpertValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpertValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpertValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpertValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpertValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpertValidationError) ErrorName() string { return "ExpertValidationError" }

// Error satisfies the builtin error interface
func (e ExpertValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpert.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpertValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpertValidationError{}

// Validate checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Topic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TopicMultiError, or nil if none found.
func (m *Topic) ValidateAll() error {
	return m.validate(true)
}

func (m *Topic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return TopicMultiError(errors)
	}

	return nil
}

// TopicMultiError is an error wrapping multiple validation errors returned by
// Topic.ValidateAll() if the designated constraints aren't met.
type TopicMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopicMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopicMultiError) AllErrors() []error { return m }

// TopicValidationError is the validation error returned by Topic.Validate if
// the designated constraints aren't met.
type TopicValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopicValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopicValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopicValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopicValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopicValidationError) ErrorName() string { return "TopicValidationError" }

// Error satisfies the builtin error interface
func (e TopicValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopicValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopicValidationError{}

// Validate checks the field values on AddNoteParams with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddNoteParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddNoteParamsMultiError, or
// nil if none found.
func (m *AddNoteParams) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if len(errors) > 0 {
		return AddNoteParamsMultiError(errors)
	}

	return nil
}

// AddNoteParamsMultiError is an error wrapping multiple validation errors
// returned by AddNoteParams.ValidateAll() if the designated constraints
// aren't met.
type AddNoteParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteParamsMultiError) AllErrors() []error { return m }

// AddNoteParamsValidationError is the validation error returned by
// AddNoteParams.Validate if the designated constraints aren't met.
type AddNoteParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteParamsValidationError) ErrorName() string { return "AddNoteParamsValidationError" }

// Error satisfies the builtin error interface
func (e AddNoteParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteParamsValidationError{}
