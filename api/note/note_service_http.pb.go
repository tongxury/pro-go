// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v5.29.3
// source: note/note_service.proto

package notepb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationNoteServiceAddComment = "/api.note.NoteService/AddComment"
const OperationNoteServiceAddMeeting = "/api.note.NoteService/AddMeeting"
const OperationNoteServiceGetExpert = "/api.note.NoteService/GetExpert"
const OperationNoteServiceGetMeeting = "/api.note.NoteService/GetMeeting"
const OperationNoteServiceListComments = "/api.note.NoteService/ListComments"
const OperationNoteServiceListExperts = "/api.note.NoteService/ListExperts"
const OperationNoteServiceTest = "/api.note.NoteService/Test"
const OperationNoteServiceUpdateMeetingQuestion = "/api.note.NoteService/UpdateMeetingQuestion"

type NoteServiceHTTPServer interface {
	AddComment(context.Context, *AddCommentParams) (*Comment, error)
	AddMeeting(context.Context, *AddMeetingParams) (*Meeting, error)
	GetExpert(context.Context, *GetExpertParams) (*Expert, error)
	GetMeeting(context.Context, *GetMeetingParams) (*Meeting, error)
	ListComments(context.Context, *ListCommentsParams) (*CommentList, error)
	ListExperts(context.Context, *ListExpertsParams) (*ExpertList, error)
	Test(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	UpdateMeetingQuestion(context.Context, *UpdateMeetingQuestionParams) (*Meeting, error)
}

func RegisterNoteServiceHTTPServer(s *http.Server, srv NoteServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/sitemap.xml", _NoteService_Test0_HTTP_Handler(srv))
	r.GET("/api/ep/v1/experts", _NoteService_ListExperts0_HTTP_Handler(srv))
	r.GET("/api/ep/v1/experts/{id}", _NoteService_GetExpert0_HTTP_Handler(srv))
	r.GET("/api/ep/v1/comments", _NoteService_ListComments0_HTTP_Handler(srv))
	r.POST("/api/ep/v1/comments", _NoteService_AddComment0_HTTP_Handler(srv))
	r.POST("/api/ep/v1/meetings", _NoteService_AddMeeting0_HTTP_Handler(srv))
	r.GET("/api/ep/v1/meetings/{id}", _NoteService_GetMeeting0_HTTP_Handler(srv))
	r.PATCH("/api/ep/v1/meetings/{id}/question", _NoteService_UpdateMeetingQuestion0_HTTP_Handler(srv))
}

func _NoteService_Test0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceTest)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Test(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _NoteService_ListExperts0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListExpertsParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceListExperts)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListExperts(ctx, req.(*ListExpertsParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ExpertList)
		return ctx.Result(200, reply)
	}
}

func _NoteService_GetExpert0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetExpertParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceGetExpert)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetExpert(ctx, req.(*GetExpertParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Expert)
		return ctx.Result(200, reply)
	}
}

func _NoteService_ListComments0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListCommentsParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceListComments)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListComments(ctx, req.(*ListCommentsParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommentList)
		return ctx.Result(200, reply)
	}
}

func _NoteService_AddComment0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddCommentParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceAddComment)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddComment(ctx, req.(*AddCommentParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Comment)
		return ctx.Result(200, reply)
	}
}

func _NoteService_AddMeeting0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddMeetingParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceAddMeeting)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddMeeting(ctx, req.(*AddMeetingParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Meeting)
		return ctx.Result(200, reply)
	}
}

func _NoteService_GetMeeting0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetMeetingParams
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceGetMeeting)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMeeting(ctx, req.(*GetMeetingParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Meeting)
		return ctx.Result(200, reply)
	}
}

func _NoteService_UpdateMeetingQuestion0_HTTP_Handler(srv NoteServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateMeetingQuestionParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNoteServiceUpdateMeetingQuestion)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateMeetingQuestion(ctx, req.(*UpdateMeetingQuestionParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Meeting)
		return ctx.Result(200, reply)
	}
}

type NoteServiceHTTPClient interface {
	AddComment(ctx context.Context, req *AddCommentParams, opts ...http.CallOption) (rsp *Comment, err error)
	AddMeeting(ctx context.Context, req *AddMeetingParams, opts ...http.CallOption) (rsp *Meeting, err error)
	GetExpert(ctx context.Context, req *GetExpertParams, opts ...http.CallOption) (rsp *Expert, err error)
	GetMeeting(ctx context.Context, req *GetMeetingParams, opts ...http.CallOption) (rsp *Meeting, err error)
	ListComments(ctx context.Context, req *ListCommentsParams, opts ...http.CallOption) (rsp *CommentList, err error)
	ListExperts(ctx context.Context, req *ListExpertsParams, opts ...http.CallOption) (rsp *ExpertList, err error)
	Test(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	UpdateMeetingQuestion(ctx context.Context, req *UpdateMeetingQuestionParams, opts ...http.CallOption) (rsp *Meeting, err error)
}

type NoteServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewNoteServiceHTTPClient(client *http.Client) NoteServiceHTTPClient {
	return &NoteServiceHTTPClientImpl{client}
}

func (c *NoteServiceHTTPClientImpl) AddComment(ctx context.Context, in *AddCommentParams, opts ...http.CallOption) (*Comment, error) {
	var out Comment
	pattern := "/api/ep/v1/comments"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationNoteServiceAddComment))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) AddMeeting(ctx context.Context, in *AddMeetingParams, opts ...http.CallOption) (*Meeting, error) {
	var out Meeting
	pattern := "/api/ep/v1/meetings"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationNoteServiceAddMeeting))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) GetExpert(ctx context.Context, in *GetExpertParams, opts ...http.CallOption) (*Expert, error) {
	var out Expert
	pattern := "/api/ep/v1/experts/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNoteServiceGetExpert))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) GetMeeting(ctx context.Context, in *GetMeetingParams, opts ...http.CallOption) (*Meeting, error) {
	var out Meeting
	pattern := "/api/ep/v1/meetings/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNoteServiceGetMeeting))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) ListComments(ctx context.Context, in *ListCommentsParams, opts ...http.CallOption) (*CommentList, error) {
	var out CommentList
	pattern := "/api/ep/v1/comments"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNoteServiceListComments))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) ListExperts(ctx context.Context, in *ListExpertsParams, opts ...http.CallOption) (*ExpertList, error) {
	var out ExpertList
	pattern := "/api/ep/v1/experts"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNoteServiceListExperts))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) Test(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/sitemap.xml"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNoteServiceTest))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *NoteServiceHTTPClientImpl) UpdateMeetingQuestion(ctx context.Context, in *UpdateMeetingQuestionParams, opts ...http.CallOption) (*Meeting, error) {
	var out Meeting
	pattern := "/api/ep/v1/meetings/{id}/question"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationNoteServiceUpdateMeetingQuestion))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
