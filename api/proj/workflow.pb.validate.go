// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proj/workflow.proto

package projpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SegmentScript with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SegmentScript) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentScript with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SegmentScriptMultiError, or
// nil if none found.
func (m *SegmentScript) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentScript) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Inspiration

	// no validation rules for Script

	for idx, item := range m.GetSegments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentScriptValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentScriptValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentScriptValidationError{
					field:  fmt.Sprintf("Segments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentScriptMultiError(errors)
	}

	return nil
}

// SegmentScriptMultiError is an error wrapping multiple validation errors
// returned by SegmentScript.ValidateAll() if the designated constraints
// aren't met.
type SegmentScriptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentScriptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentScriptMultiError) AllErrors() []error { return m }

// SegmentScriptValidationError is the validation error returned by
// SegmentScript.Validate if the designated constraints aren't met.
type SegmentScriptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentScriptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentScriptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentScriptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentScriptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentScriptValidationError) ErrorName() string { return "SegmentScriptValidationError" }

// Error satisfies the builtin error interface
func (e SegmentScriptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentScript.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentScriptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentScriptValidationError{}

// Validate checks the field values on VideoGeneration with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VideoGeneration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VideoGeneration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VideoGenerationMultiError, or nil if none found.
func (m *VideoGeneration) ValidateAll() error {
	return m.validate(true)
}

func (m *VideoGeneration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for TaskId

	// no validation rules for Status

	// no validation rules for CoverUrl

	// no validation rules for FirstFrame

	// no validation rules for LastFrame

	// no validation rules for Prompt

	// no validation rules for TmpPrompt

	// no validation rules for Subtitle

	// no validation rules for AspectRatio

	// no validation rules for Duration

	// no validation rules for Category

	// no validation rules for Error

	if len(errors) > 0 {
		return VideoGenerationMultiError(errors)
	}

	return nil
}

// VideoGenerationMultiError is an error wrapping multiple validation errors
// returned by VideoGeneration.ValidateAll() if the designated constraints
// aren't met.
type VideoGenerationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VideoGenerationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VideoGenerationMultiError) AllErrors() []error { return m }

// VideoGenerationValidationError is the validation error returned by
// VideoGeneration.Validate if the designated constraints aren't met.
type VideoGenerationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VideoGenerationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VideoGenerationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VideoGenerationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VideoGenerationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VideoGenerationValidationError) ErrorName() string { return "VideoGenerationValidationError" }

// Error satisfies the builtin error interface
func (e VideoGenerationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVideoGeneration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VideoGenerationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VideoGenerationValidationError{}

// Validate checks the field values on VideoFramesChange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VideoFramesChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VideoFramesChange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VideoFramesChangeMultiError, or nil if none found.
func (m *VideoFramesChange) ValidateAll() error {
	return m.validate(true)
}

func (m *VideoFramesChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FirstFrame

	// no validation rules for NewFirstFrame

	// no validation rules for LastFrame

	// no validation rules for NewLastFrame

	// no validation rules for Ref

	if len(errors) > 0 {
		return VideoFramesChangeMultiError(errors)
	}

	return nil
}

// VideoFramesChangeMultiError is an error wrapping multiple validation errors
// returned by VideoFramesChange.ValidateAll() if the designated constraints
// aren't met.
type VideoFramesChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VideoFramesChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VideoFramesChangeMultiError) AllErrors() []error { return m }

// VideoFramesChangeValidationError is the validation error returned by
// VideoFramesChange.Validate if the designated constraints aren't met.
type VideoFramesChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VideoFramesChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VideoFramesChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VideoFramesChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VideoFramesChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VideoFramesChangeValidationError) ErrorName() string {
	return "VideoFramesChangeValidationError"
}

// Error satisfies the builtin error interface
func (e VideoFramesChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVideoFramesChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VideoFramesChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VideoFramesChangeValidationError{}

// Validate checks the field values on Remix with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Remix) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Remix with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RemixMultiError, or nil if none found.
func (m *Remix) ValidateAll() error {
	return m.validate(true)
}

func (m *Remix) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for CoverUrl

	// no validation rules for TaskId

	for idx, item := range m.GetSegments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RemixValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RemixValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RemixValidationError{
					field:  fmt.Sprintf("Segments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if len(errors) > 0 {
		return RemixMultiError(errors)
	}

	return nil
}

// RemixMultiError is an error wrapping multiple validation errors returned by
// Remix.ValidateAll() if the designated constraints aren't met.
type RemixMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemixMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemixMultiError) AllErrors() []error { return m }

// RemixValidationError is the validation error returned by Remix.Validate if
// the designated constraints aren't met.
type RemixValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemixValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemixValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemixValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemixValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemixValidationError) ErrorName() string { return "RemixValidationError" }

// Error satisfies the builtin error interface
func (e RemixValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemix.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemixValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemixValidationError{}

// Validate checks the field values on KeyFrames with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyFrames) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyFrames with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyFramesMultiError, or nil
// if none found.
func (m *KeyFrames) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyFrames) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFrames() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyFramesValidationError{
						field:  fmt.Sprintf("Frames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyFramesValidationError{
						field:  fmt.Sprintf("Frames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyFramesValidationError{
					field:  fmt.Sprintf("Frames[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TaskId

	if len(errors) > 0 {
		return KeyFramesMultiError(errors)
	}

	return nil
}

// KeyFramesMultiError is an error wrapping multiple validation errors returned
// by KeyFrames.ValidateAll() if the designated constraints aren't met.
type KeyFramesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyFramesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyFramesMultiError) AllErrors() []error { return m }

// KeyFramesValidationError is the validation error returned by
// KeyFrames.Validate if the designated constraints aren't met.
type KeyFramesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyFramesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyFramesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyFramesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyFramesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyFramesValidationError) ErrorName() string { return "KeyFramesValidationError" }

// Error satisfies the builtin error interface
func (e KeyFramesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyFrames.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyFramesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyFramesValidationError{}

// Validate checks the field values on DataBus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataBus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataBus with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DataBusMultiError, or nil if none found.
func (m *DataBus) ValidateAll() error {
	return m.validate(true)
}

func (m *DataBus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommodity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Commodity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Commodity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommodity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "Commodity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVideoGenerations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataBusValidationError{
						field:  fmt.Sprintf("VideoGenerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataBusValidationError{
						field:  fmt.Sprintf("VideoGenerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataBusValidationError{
					field:  fmt.Sprintf("VideoGenerations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVideoFramesChanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataBusValidationError{
						field:  fmt.Sprintf("VideoFramesChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataBusValidationError{
						field:  fmt.Sprintf("VideoFramesChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataBusValidationError{
					field:  fmt.Sprintf("VideoFramesChanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemix()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Remix",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "Remix",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemix()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "Remix",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSegmentScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "SegmentScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "SegmentScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegmentScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "SegmentScript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKeyFrames()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "KeyFrames",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataBusValidationError{
					field:  "KeyFrames",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyFrames()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataBusValidationError{
				field:  "KeyFrames",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DataBusMultiError(errors)
	}

	return nil
}

// DataBusMultiError is an error wrapping multiple validation errors returned
// by DataBus.ValidateAll() if the designated constraints aren't met.
type DataBusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataBusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataBusMultiError) AllErrors() []error { return m }

// DataBusValidationError is the validation error returned by DataBus.Validate
// if the designated constraints aren't met.
type DataBusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataBusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataBusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataBusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataBusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataBusValidationError) ErrorName() string { return "DataBusValidationError" }

// Error satisfies the builtin error interface
func (e DataBusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataBus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataBusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataBusValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Index

	// no validation rules for Status

	// no validation rules for StartedAt

	// no validation rules for CompletedAt

	if all {
		switch v := interface{}(m.GetProgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "Progress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataBus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "DataBus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "DataBus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataBus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "DataBus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on Workflow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workflow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowMultiError, or nil
// if none found.
func (m *Workflow) ValidateAll() error {
	return m.validate(true)
}

func (m *Workflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XId

	// no validation rules for Name

	// no validation rules for Current

	for idx, item := range m.GetJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowValidationError{
					field:  fmt.Sprintf("Jobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CreatedAt

	// no validation rules for Status

	// no validation rules for CompletedAt

	// no validation rules for LastResumedAt

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetDataBus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "DataBus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowValidationError{
					field:  "DataBus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataBus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowValidationError{
				field:  "DataBus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkflowMultiError(errors)
	}

	return nil
}

// WorkflowMultiError is an error wrapping multiple validation errors returned
// by Workflow.ValidateAll() if the designated constraints aren't met.
type WorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowMultiError) AllErrors() []error { return m }

// WorkflowValidationError is the validation error returned by
// Workflow.Validate if the designated constraints aren't met.
type WorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowValidationError) ErrorName() string { return "WorkflowValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowValidationError{}

// Validate checks the field values on Remix_Segment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Remix_Segment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Remix_Segment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Remix_SegmentMultiError, or
// nil if none found.
func (m *Remix_Segment) ValidateAll() error {
	return m.validate(true)
}

func (m *Remix_Segment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MediaId

	if all {
		switch v := interface{}(m.GetVideoGeneration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "VideoGeneration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "VideoGeneration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideoGeneration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Remix_SegmentValidationError{
				field:  "VideoGeneration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemixOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "RemixOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "RemixOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemixOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Remix_SegmentValidationError{
				field:  "RemixOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScriptSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "ScriptSegment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Remix_SegmentValidationError{
					field:  "ScriptSegment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScriptSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Remix_SegmentValidationError{
				field:  "ScriptSegment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Remix_SegmentMultiError(errors)
	}

	return nil
}

// Remix_SegmentMultiError is an error wrapping multiple validation errors
// returned by Remix_Segment.ValidateAll() if the designated constraints
// aren't met.
type Remix_SegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Remix_SegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Remix_SegmentMultiError) AllErrors() []error { return m }

// Remix_SegmentValidationError is the validation error returned by
// Remix_Segment.Validate if the designated constraints aren't met.
type Remix_SegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Remix_SegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Remix_SegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Remix_SegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Remix_SegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Remix_SegmentValidationError) ErrorName() string { return "Remix_SegmentValidationError" }

// Error satisfies the builtin error interface
func (e Remix_SegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemix_Segment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Remix_SegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Remix_SegmentValidationError{}

// Validate checks the field values on KeyFrames_Frame with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KeyFrames_Frame) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyFrames_Frame with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KeyFrames_FrameMultiError, or nil if none found.
func (m *KeyFrames_Frame) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyFrames_Frame) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Desc

	// no validation rules for Status

	// no validation rules for Prompt

	// no validation rules for TaskId

	// no validation rules for AspectRatio

	// no validation rules for Error

	if len(errors) > 0 {
		return KeyFrames_FrameMultiError(errors)
	}

	return nil
}

// KeyFrames_FrameMultiError is an error wrapping multiple validation errors
// returned by KeyFrames_Frame.ValidateAll() if the designated constraints
// aren't met.
type KeyFrames_FrameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyFrames_FrameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyFrames_FrameMultiError) AllErrors() []error { return m }

// KeyFrames_FrameValidationError is the validation error returned by
// KeyFrames_Frame.Validate if the designated constraints aren't met.
type KeyFrames_FrameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyFrames_FrameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyFrames_FrameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyFrames_FrameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyFrames_FrameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyFrames_FrameValidationError) ErrorName() string { return "KeyFrames_FrameValidationError" }

// Error satisfies the builtin error interface
func (e KeyFrames_FrameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyFrames_Frame.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyFrames_FrameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyFrames_FrameValidationError{}

// Validate checks the field values on DataBus_Settings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataBus_Settings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataBus_Settings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataBus_SettingsMultiError, or nil if none found.
func (m *DataBus_Settings) ValidateAll() error {
	return m.validate(true)
}

func (m *DataBus_Settings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AspectRatio

	if len(errors) > 0 {
		return DataBus_SettingsMultiError(errors)
	}

	return nil
}

// DataBus_SettingsMultiError is an error wrapping multiple validation errors
// returned by DataBus_Settings.ValidateAll() if the designated constraints
// aren't met.
type DataBus_SettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataBus_SettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataBus_SettingsMultiError) AllErrors() []error { return m }

// DataBus_SettingsValidationError is the validation error returned by
// DataBus_Settings.Validate if the designated constraints aren't met.
type DataBus_SettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataBus_SettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataBus_SettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataBus_SettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataBus_SettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataBus_SettingsValidationError) ErrorName() string { return "DataBus_SettingsValidationError" }

// Error satisfies the builtin error interface
func (e DataBus_SettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataBus_Settings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataBus_SettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataBus_SettingsValidationError{}

// Validate checks the field values on Job_Progress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Job_Progress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job_Progress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Job_ProgressMultiError, or
// nil if none found.
func (m *Job_Progress) ValidateAll() error {
	return m.validate(true)
}

func (m *Job_Progress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Current

	if len(errors) > 0 {
		return Job_ProgressMultiError(errors)
	}

	return nil
}

// Job_ProgressMultiError is an error wrapping multiple validation errors
// returned by Job_Progress.ValidateAll() if the designated constraints aren't met.
type Job_ProgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Job_ProgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Job_ProgressMultiError) AllErrors() []error { return m }

// Job_ProgressValidationError is the validation error returned by
// Job_Progress.Validate if the designated constraints aren't met.
type Job_ProgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Job_ProgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Job_ProgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Job_ProgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Job_ProgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Job_ProgressValidationError) ErrorName() string { return "Job_ProgressValidationError" }

// Error satisfies the builtin error interface
func (e Job_ProgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob_Progress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Job_ProgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Job_ProgressValidationError{}
