// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: chat/chat.proto

package chatpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on HomeworkParams with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HomeworkParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HomeworkParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HomeworkParamsMultiError,
// or nil if none found.
func (m *HomeworkParams) ValidateAll() error {
	return m.validate(true)
}

func (m *HomeworkParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionKey

	if len(errors) > 0 {
		return HomeworkParamsMultiError(errors)
	}

	return nil
}

// HomeworkParamsMultiError is an error wrapping multiple validation errors
// returned by HomeworkParams.ValidateAll() if the designated constraints
// aren't met.
type HomeworkParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HomeworkParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HomeworkParamsMultiError) AllErrors() []error { return m }

// HomeworkParamsValidationError is the validation error returned by
// HomeworkParams.Validate if the designated constraints aren't met.
type HomeworkParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HomeworkParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HomeworkParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HomeworkParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HomeworkParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HomeworkParamsValidationError) ErrorName() string { return "HomeworkParamsValidationError" }

// Error satisfies the builtin error interface
func (e HomeworkParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHomeworkParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HomeworkParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HomeworkParamsValidationError{}

// Validate checks the field values on SitemapUrlSetParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SitemapUrlSetParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SitemapUrlSetParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SitemapUrlSetParamsMultiError, or nil if none found.
func (m *SitemapUrlSetParams) ValidateAll() error {
	return m.validate(true)
}

func (m *SitemapUrlSetParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SitemapKey

	if len(errors) > 0 {
		return SitemapUrlSetParamsMultiError(errors)
	}

	return nil
}

// SitemapUrlSetParamsMultiError is an error wrapping multiple validation
// errors returned by SitemapUrlSetParams.ValidateAll() if the designated
// constraints aren't met.
type SitemapUrlSetParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SitemapUrlSetParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SitemapUrlSetParamsMultiError) AllErrors() []error { return m }

// SitemapUrlSetParamsValidationError is the validation error returned by
// SitemapUrlSetParams.Validate if the designated constraints aren't met.
type SitemapUrlSetParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SitemapUrlSetParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SitemapUrlSetParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SitemapUrlSetParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SitemapUrlSetParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SitemapUrlSetParamsValidationError) ErrorName() string {
	return "SitemapUrlSetParamsValidationError"
}

// Error satisfies the builtin error interface
func (e SitemapUrlSetParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSitemapUrlSetParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SitemapUrlSetParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SitemapUrlSetParamsValidationError{}

// Validate checks the field values on UpdateAnswerStateParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAnswerStateParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAnswerStateParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAnswerStateParamsMultiError, or nil if none found.
func (m *UpdateAnswerStateParams) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAnswerStateParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AnswerId

	// no validation rules for Fields

	if len(errors) > 0 {
		return UpdateAnswerStateParamsMultiError(errors)
	}

	return nil
}

// UpdateAnswerStateParamsMultiError is an error wrapping multiple validation
// errors returned by UpdateAnswerStateParams.ValidateAll() if the designated
// constraints aren't met.
type UpdateAnswerStateParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAnswerStateParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAnswerStateParamsMultiError) AllErrors() []error { return m }

// UpdateAnswerStateParamsValidationError is the validation error returned by
// UpdateAnswerStateParams.Validate if the designated constraints aren't met.
type UpdateAnswerStateParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAnswerStateParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAnswerStateParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAnswerStateParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAnswerStateParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAnswerStateParamsValidationError) ErrorName() string {
	return "UpdateAnswerStateParamsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAnswerStateParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAnswerStateParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAnswerStateParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAnswerStateParamsValidationError{}

// Validate checks the field values on ListQuestionsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQuestionsParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQuestionsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQuestionsParamsMultiError, or nil if none found.
func (m *ListQuestionsParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQuestionsParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for SimilarWith

	// no validation rules for Scenario

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListQuestionsParamsMultiError(errors)
	}

	return nil
}

// ListQuestionsParamsMultiError is an error wrapping multiple validation
// errors returned by ListQuestionsParams.ValidateAll() if the designated
// constraints aren't met.
type ListQuestionsParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQuestionsParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQuestionsParamsMultiError) AllErrors() []error { return m }

// ListQuestionsParamsValidationError is the validation error returned by
// ListQuestionsParams.Validate if the designated constraints aren't met.
type ListQuestionsParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQuestionsParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQuestionsParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQuestionsParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQuestionsParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQuestionsParamsValidationError) ErrorName() string {
	return "ListQuestionsParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListQuestionsParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQuestionsParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQuestionsParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQuestionsParamsValidationError{}

// Validate checks the field values on Questions with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Questions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Questions with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuestionsMultiError, or nil
// if none found.
func (m *Questions) ValidateAll() error {
	return m.validate(true)
}

func (m *Questions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuestionsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuestionsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuestionsValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return QuestionsMultiError(errors)
	}

	return nil
}

// QuestionsMultiError is an error wrapping multiple validation errors returned
// by Questions.ValidateAll() if the designated constraints aren't met.
type QuestionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuestionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuestionsMultiError) AllErrors() []error { return m }

// QuestionsValidationError is the validation error returned by
// Questions.Validate if the designated constraints aren't met.
type QuestionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuestionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuestionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuestionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuestionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuestionsValidationError) ErrorName() string { return "QuestionsValidationError" }

// Error satisfies the builtin error interface
func (e QuestionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuestions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuestionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuestionsValidationError{}

// Validate checks the field values on PreQuestions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PreQuestions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreQuestions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PreQuestionsMultiError, or
// nil if none found.
func (m *PreQuestions) ValidateAll() error {
	return m.validate(true)
}

func (m *PreQuestions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PreQuestionsValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PreQuestionsValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PreQuestionsValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PreQuestionsMultiError(errors)
	}

	return nil
}

// PreQuestionsMultiError is an error wrapping multiple validation errors
// returned by PreQuestions.ValidateAll() if the designated constraints aren't met.
type PreQuestionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreQuestionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreQuestionsMultiError) AllErrors() []error { return m }

// PreQuestionsValidationError is the validation error returned by
// PreQuestions.Validate if the designated constraints aren't met.
type PreQuestionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreQuestionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreQuestionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreQuestionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreQuestionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreQuestionsValidationError) ErrorName() string { return "PreQuestionsValidationError" }

// Error satisfies the builtin error interface
func (e PreQuestionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreQuestions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreQuestionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreQuestionsValidationError{}

// Validate checks the field values on TranslateParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TranslateParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TranslateParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TranslateParamsMultiError, or nil if none found.
func (m *TranslateParams) ValidateAll() error {
	return m.validate(true)
}

func (m *TranslateParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetLang

	if len(errors) > 0 {
		return TranslateParamsMultiError(errors)
	}

	return nil
}

// TranslateParamsMultiError is an error wrapping multiple validation errors
// returned by TranslateParams.ValidateAll() if the designated constraints
// aren't met.
type TranslateParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TranslateParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TranslateParamsMultiError) AllErrors() []error { return m }

// TranslateParamsValidationError is the validation error returned by
// TranslateParams.Validate if the designated constraints aren't met.
type TranslateParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TranslateParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TranslateParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TranslateParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TranslateParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TranslateParamsValidationError) ErrorName() string { return "TranslateParamsValidationError" }

// Error satisfies the builtin error interface
func (e TranslateParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTranslateParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TranslateParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TranslateParamsValidationError{}

// Validate checks the field values on Translation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Translation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Translation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TranslationMultiError, or
// nil if none found.
func (m *Translation) ValidateAll() error {
	return m.validate(true)
}

func (m *Translation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetLang

	if len(errors) > 0 {
		return TranslationMultiError(errors)
	}

	return nil
}

// TranslationMultiError is an error wrapping multiple validation errors
// returned by Translation.ValidateAll() if the designated constraints aren't met.
type TranslationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TranslationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TranslationMultiError) AllErrors() []error { return m }

// TranslationValidationError is the validation error returned by
// Translation.Validate if the designated constraints aren't met.
type TranslationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TranslationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TranslationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TranslationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TranslationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TranslationValidationError) ErrorName() string { return "TranslationValidationError" }

// Error satisfies the builtin error interface
func (e TranslationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTranslation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TranslationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TranslationValidationError{}

// Validate checks the field values on QuestionAnswer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuestionAnswer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuestionAnswer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuestionAnswerMultiError,
// or nil if none found.
func (m *QuestionAnswer) ValidateAll() error {
	return m.validate(true)
}

func (m *QuestionAnswer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuestionAnswerValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuestionAnswerValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuestionAnswerValidationError{
				field:  "Question",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuestionAnswerValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuestionAnswerValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuestionAnswerValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QuestionAnswerMultiError(errors)
	}

	return nil
}

// QuestionAnswerMultiError is an error wrapping multiple validation errors
// returned by QuestionAnswer.ValidateAll() if the designated constraints
// aren't met.
type QuestionAnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuestionAnswerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuestionAnswerMultiError) AllErrors() []error { return m }

// QuestionAnswerValidationError is the validation error returned by
// QuestionAnswer.Validate if the designated constraints aren't met.
type QuestionAnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuestionAnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuestionAnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuestionAnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuestionAnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuestionAnswerValidationError) ErrorName() string { return "QuestionAnswerValidationError" }

// Error satisfies the builtin error interface
func (e QuestionAnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuestionAnswer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuestionAnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuestionAnswerValidationError{}

// Validate checks the field values on Summary with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Summary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Summary with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SummaryMultiError, or nil if none found.
func (m *Summary) ValidateAll() error {
	return m.validate(true)
}

func (m *Summary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SummaryValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SummaryValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SummaryValidationError{
				field:  "Question",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAnswer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SummaryValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SummaryValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnswer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SummaryValidationError{
				field:  "Answer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SummaryMultiError(errors)
	}

	return nil
}

// SummaryMultiError is an error wrapping multiple validation errors returned
// by Summary.ValidateAll() if the designated constraints aren't met.
type SummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SummaryMultiError) AllErrors() []error { return m }

// SummaryValidationError is the validation error returned by Summary.Validate
// if the designated constraints aren't met.
type SummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SummaryValidationError) ErrorName() string { return "SummaryValidationError" }

// Error satisfies the builtin error interface
func (e SummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SummaryValidationError{}

// Validate checks the field values on ListQuestionAnswersParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQuestionAnswersParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQuestionAnswersParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQuestionAnswersParamsMultiError, or nil if none found.
func (m *ListQuestionAnswersParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQuestionAnswersParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListQuestionAnswersParamsMultiError(errors)
	}

	return nil
}

// ListQuestionAnswersParamsMultiError is an error wrapping multiple validation
// errors returned by ListQuestionAnswersParams.ValidateAll() if the
// designated constraints aren't met.
type ListQuestionAnswersParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQuestionAnswersParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQuestionAnswersParamsMultiError) AllErrors() []error { return m }

// ListQuestionAnswersParamsValidationError is the validation error returned by
// ListQuestionAnswersParams.Validate if the designated constraints aren't met.
type ListQuestionAnswersParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQuestionAnswersParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQuestionAnswersParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQuestionAnswersParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQuestionAnswersParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQuestionAnswersParamsValidationError) ErrorName() string {
	return "ListQuestionAnswersParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListQuestionAnswersParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQuestionAnswersParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQuestionAnswersParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQuestionAnswersParamsValidationError{}

// Validate checks the field values on ListQuestionAnswersResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQuestionAnswersResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQuestionAnswersResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQuestionAnswersResultMultiError, or nil if none found.
func (m *ListQuestionAnswersResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQuestionAnswersResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQuestionAnswersResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQuestionAnswersResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQuestionAnswersResultValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListQuestionAnswersResultMultiError(errors)
	}

	return nil
}

// ListQuestionAnswersResultMultiError is an error wrapping multiple validation
// errors returned by ListQuestionAnswersResult.ValidateAll() if the
// designated constraints aren't met.
type ListQuestionAnswersResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQuestionAnswersResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQuestionAnswersResultMultiError) AllErrors() []error { return m }

// ListQuestionAnswersResultValidationError is the validation error returned by
// ListQuestionAnswersResult.Validate if the designated constraints aren't met.
type ListQuestionAnswersResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQuestionAnswersResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQuestionAnswersResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQuestionAnswersResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQuestionAnswersResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQuestionAnswersResultValidationError) ErrorName() string {
	return "ListQuestionAnswersResultValidationError"
}

// Error satisfies the builtin error interface
func (e ListQuestionAnswersResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQuestionAnswersResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQuestionAnswersResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQuestionAnswersResultValidationError{}

// Validate checks the field values on ListSessionsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSessionsParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSessionsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSessionsParamsMultiError, or nil if none found.
func (m *ListSessionsParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSessionsParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return ListSessionsParamsMultiError(errors)
	}

	return nil
}

// ListSessionsParamsMultiError is an error wrapping multiple validation errors
// returned by ListSessionsParams.ValidateAll() if the designated constraints
// aren't met.
type ListSessionsParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSessionsParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSessionsParamsMultiError) AllErrors() []error { return m }

// ListSessionsParamsValidationError is the validation error returned by
// ListSessionsParams.Validate if the designated constraints aren't met.
type ListSessionsParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSessionsParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSessionsParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSessionsParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSessionsParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSessionsParamsValidationError) ErrorName() string {
	return "ListSessionsParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListSessionsParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSessionsParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSessionsParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSessionsParamsValidationError{}

// Validate checks the field values on Sessions with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sessions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sessions with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SessionsMultiError, or nil
// if none found.
func (m *Sessions) ValidateAll() error {
	return m.validate(true)
}

func (m *Sessions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionsValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return SessionsMultiError(errors)
	}

	return nil
}

// SessionsMultiError is an error wrapping multiple validation errors returned
// by Sessions.ValidateAll() if the designated constraints aren't met.
type SessionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionsMultiError) AllErrors() []error { return m }

// SessionsValidationError is the validation error returned by
// Sessions.Validate if the designated constraints aren't met.
type SessionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionsValidationError) ErrorName() string { return "SessionsValidationError" }

// Error satisfies the builtin error interface
func (e SessionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionsValidationError{}

// Validate checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Session) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SessionMultiError, or nil if none found.
func (m *Session) ValidateAll() error {
	return m.validate(true)
}

func (m *Session) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedAt

	// no validation rules for LastAskAt

	// no validation rules for Title

	// no validation rules for Summary

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Scenario

	// no validation rules for UserId

	if len(errors) > 0 {
		return SessionMultiError(errors)
	}

	return nil
}

// SessionMultiError is an error wrapping multiple validation errors returned
// by Session.ValidateAll() if the designated constraints aren't met.
type SessionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionMultiError) AllErrors() []error { return m }

// SessionValidationError is the validation error returned by Session.Validate
// if the designated constraints aren't met.
type SessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionValidationError) ErrorName() string { return "SessionValidationError" }

// Error satisfies the builtin error interface
func (e SessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionValidationError{}

// Validate checks the field values on Question with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Question) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Question with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuestionMultiError, or nil
// if none found.
func (m *Question) ValidateAll() error {
	return m.validate(true)
}

func (m *Question) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrompt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "Prompt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "Prompt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrompt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuestionValidationError{
				field:  "Prompt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	if all {
		switch v := interface{}(m.GetAttachment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "Attachment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuestionValidationError{
					field:  "Attachment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttachment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuestionValidationError{
				field:  "Attachment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuestionValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuestionValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuestionValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UserId

	// no validation rules for Location

	// no validation rules for SessionId

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuestionValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuestionValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuestionValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Id

	// no validation rules for Scenario

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return QuestionMultiError(errors)
	}

	return nil
}

// QuestionMultiError is an error wrapping multiple validation errors returned
// by Question.ValidateAll() if the designated constraints aren't met.
type QuestionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuestionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuestionMultiError) AllErrors() []error { return m }

// QuestionValidationError is the validation error returned by
// Question.Validate if the designated constraints aren't met.
type QuestionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuestionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuestionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuestionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuestionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuestionValidationError) ErrorName() string { return "QuestionValidationError" }

// Error satisfies the builtin error interface
func (e QuestionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuestion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuestionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuestionValidationError{}

// Validate checks the field values on Attachment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Attachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Attachment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AttachmentMultiError, or
// nil if none found.
func (m *Attachment) ValidateAll() error {
	return m.validate(true)
}

func (m *Attachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Category

	// no validation rules for Url

	// no validation rules for Name

	// no validation rules for Content

	if len(errors) > 0 {
		return AttachmentMultiError(errors)
	}

	return nil
}

// AttachmentMultiError is an error wrapping multiple validation errors
// returned by Attachment.ValidateAll() if the designated constraints aren't met.
type AttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentMultiError) AllErrors() []error { return m }

// AttachmentValidationError is the validation error returned by
// Attachment.Validate if the designated constraints aren't met.
type AttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentValidationError) ErrorName() string { return "AttachmentValidationError" }

// Error satisfies the builtin error interface
func (e AttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentValidationError{}

// Validate checks the field values on Answer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Answer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Answer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AnswerMultiError, or nil if none found.
func (m *Answer) ValidateAll() error {
	return m.validate(true)
}

func (m *Answer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuestionId

	// no validation rules for Text

	// no validation rules for SessionId

	// no validation rules for UserId

	// no validation rules for Id

	// no validation rules for Scenario

	if all {
		switch v := interface{}(m.GetAnswerState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnswerValidationError{
					field:  "AnswerState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnswerValidationError{
					field:  "AnswerState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnswerState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnswerValidationError{
				field:  "AnswerState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AnswerMultiError(errors)
	}

	return nil
}

// AnswerMultiError is an error wrapping multiple validation errors returned by
// Answer.ValidateAll() if the designated constraints aren't met.
type AnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnswerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnswerMultiError) AllErrors() []error { return m }

// AnswerValidationError is the validation error returned by Answer.Validate if
// the designated constraints aren't met.
type AnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnswerValidationError) ErrorName() string { return "AnswerValidationError" }

// Error satisfies the builtin error interface
func (e AnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnswer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnswerValidationError{}

// Validate checks the field values on AnswerState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AnswerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnswerState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnswerStateMultiError, or
// nil if none found.
func (m *AnswerState) ValidateAll() error {
	return m.validate(true)
}

func (m *AnswerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LikeCount

	// no validation rules for Liked

	if len(errors) > 0 {
		return AnswerStateMultiError(errors)
	}

	return nil
}

// AnswerStateMultiError is an error wrapping multiple validation errors
// returned by AnswerState.ValidateAll() if the designated constraints aren't met.
type AnswerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnswerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnswerStateMultiError) AllErrors() []error { return m }

// AnswerStateValidationError is the validation error returned by
// AnswerState.Validate if the designated constraints aren't met.
type AnswerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnswerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnswerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnswerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnswerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnswerStateValidationError) ErrorName() string { return "AnswerStateValidationError" }

// Error satisfies the builtin error interface
func (e AnswerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnswerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnswerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnswerStateValidationError{}

// Validate checks the field values on Prompt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Prompt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Prompt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PromptMultiError, or nil if none found.
func (m *Prompt) ValidateAll() error {
	return m.validate(true)
}

func (m *Prompt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Text

	// no validation rules for Params

	if len(errors) > 0 {
		return PromptMultiError(errors)
	}

	return nil
}

// PromptMultiError is an error wrapping multiple validation errors returned by
// Prompt.ValidateAll() if the designated constraints aren't met.
type PromptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PromptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PromptMultiError) AllErrors() []error { return m }

// PromptValidationError is the validation error returned by Prompt.Validate if
// the designated constraints aren't met.
type PromptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PromptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PromptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PromptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PromptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PromptValidationError) ErrorName() string { return "PromptValidationError" }

// Error satisfies the builtin error interface
func (e PromptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrompt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PromptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PromptValidationError{}

// Validate checks the field values on ListChatRecordsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChatRecordsParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChatRecordsParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChatRecordsParamsMultiError, or nil if none found.
func (m *ListChatRecordsParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChatRecordsParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for FromTs

	// no validation rules for ToTs

	if len(errors) > 0 {
		return ListChatRecordsParamsMultiError(errors)
	}

	return nil
}

// ListChatRecordsParamsMultiError is an error wrapping multiple validation
// errors returned by ListChatRecordsParams.ValidateAll() if the designated
// constraints aren't met.
type ListChatRecordsParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChatRecordsParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChatRecordsParamsMultiError) AllErrors() []error { return m }

// ListChatRecordsParamsValidationError is the validation error returned by
// ListChatRecordsParams.Validate if the designated constraints aren't met.
type ListChatRecordsParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChatRecordsParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChatRecordsParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChatRecordsParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChatRecordsParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChatRecordsParamsValidationError) ErrorName() string {
	return "ListChatRecordsParamsValidationError"
}

// Error satisfies the builtin error interface
func (e ListChatRecordsParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChatRecordsParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChatRecordsParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChatRecordsParamsValidationError{}

// Validate checks the field values on ListChatRecordsResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChatRecordsResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChatRecordsResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChatRecordsResultMultiError, or nil if none found.
func (m *ListChatRecordsResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChatRecordsResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListChatRecordsResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListChatRecordsResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListChatRecordsResultValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListChatRecordsResultMultiError(errors)
	}

	return nil
}

// ListChatRecordsResultMultiError is an error wrapping multiple validation
// errors returned by ListChatRecordsResult.ValidateAll() if the designated
// constraints aren't met.
type ListChatRecordsResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChatRecordsResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChatRecordsResultMultiError) AllErrors() []error { return m }

// ListChatRecordsResultValidationError is the validation error returned by
// ListChatRecordsResult.Validate if the designated constraints aren't met.
type ListChatRecordsResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChatRecordsResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChatRecordsResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChatRecordsResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChatRecordsResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChatRecordsResultValidationError) ErrorName() string {
	return "ListChatRecordsResultValidationError"
}

// Error satisfies the builtin error interface
func (e ListChatRecordsResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChatRecordsResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChatRecordsResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChatRecordsResultValidationError{}
